// Generated by CoffeeScript 1.4.0
(function() {
  'use strict';

  var AlignResult, Pathway, SELECTED_GROUP, iEnhancedCanvas, root,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.GRID_SIZE = 4;

  window.get_c2m_point = function(p) {
    return Math.ceil(p / GRID_SIZE);
  };

  window.get_m2c_point = function(p) {
    return p * GRID_SIZE;
  };

  window.get_m2m_point = function(p) {
    return Math.ceil(p / GRID_SIZE) * GRID_SIZE;
  };

  /*
    Compound object.
    There are two types of compounds objects:
    a) Normal compound objects. They are created by the user.
    b) Virtual compound objects. They are created by the system
       to represent a few normal compounds together. They are
       identified because they have a negative ID number. There's
       a counter and it's automatically assigned.
  */


  window.Compound = (function() {

    function Compound(id, label, description, position, size, shape, color) {
      var _ref, _ref1, _ref2, _ref3;
      this.id = id;
      this.label = label;
      this.description = description;
      this.position = position;
      this.size = size;
      this.shape = shape;
      this.color = color;
      _ref = [get_m2c_point(this.position[0]), get_m2c_point(this.position[1])], this.cx = _ref[0], this.cy = _ref[1];
      _ref1 = [get_m2c_point(size[0]), get_m2c_point(size[1])], this.cw = _ref1[0], this.ch = _ref1[1];
      this.virtual = this.id < 0;
      if (this.shape === "square") {
        this.cx1 = this.cx;
        this.cy1 = this.cy;
      }
      _ref2 = [this.size[0], this.size[1]], this.mw = _ref2[0], this.mh = _ref2[1];
      _ref3 = [this.position[0] + this.mw / 2, this.position[1] + this.mh / 2], this.mx = _ref3[0], this.my = _ref3[1];
      this.draw_compound();
    }

    /*
      # function draw_compound.
      # It draws the compound. The point X, Y defines the center of the shape.
    */


    Compound.prototype.draw_compound = function() {
      var shape, text;
      if (this.shape === "circle") {
        shape = new paper.Path.Circle(new paper.Point(this.cx, this.cy), this.width);
        shape.fillColor = this.color[0];
      } else if (this.shape === "square") {
        if (this.virtual) {
          shape = new paper.Path.Rectangle(new paper.Point(this.cx - (this.cw / 2), this.cy - (this.ch / 2) + 1), new paper.Size(this.cw - 1, this.ch));
        } else {
          shape = new paper.Path.Rectangle(new paper.Point(this.cx - (this.cw / 2), this.cy - (this.ch / 2)), new paper.Size(this.cw, this.ch));
        }
        shape.fillColor = this.color[0];
      }
      if (this.virtual) {
        shape.opacity = 0.4;
        return shape.style = {
          strokeColor: 'black',
          fillColor: 'white',
          strokeWidth: 1
        };
      } else {
        if (this.cw === this.ch) {
          text = new paper.PointText(new paper.Point(this.cx - (this.cw / 2) + 22, this.cy - (this.ch / 2) + 15), new paper.Size(this.cw, this.ch));
        } else {
          text = new paper.PointText(new paper.Point(this.cx - (this.cw / 2) + 20, this.cy - (this.ch / 2) + 10), new paper.Size(this.cw, this.ch));
        }
        text.justification = 'center';
        text.fillColor = 'black';
        text.fontSize = '9px';
        return text.content = this.label;
      }
    };

    /*
         function _get_base_coords(layout, D)
          layout: 1 for north, 2 for east, 3 for south, 4 for west.
          D: delta distance. Is the distance added as offset after the layout.
    
         It returns a tuple with a new position (it's like a first leg
         from the base).
    */


    Compound.prototype._get_base_coords = function(layout, D) {
      var DX, DY, p, p_aux;
      DX = this.mw / 2;
      DY = this.mh / 2;
      switch (layout) {
        case 1:
          p = [this.mx, this.my - (this.mh / 2) - D];
          break;
        case 2:
          p = [this.mx + (this.mw / 2) + D, this.my];
          break;
        case 3:
          p = [this.mx, this.my + (this.mh / 2) + D];
          break;
        case 4:
          p = [this.mx - (this.mw / 2) - D, this.my];
      }
      p_aux = [parseInt(p[0]) - DX, parseInt(p[1] - DY)];
      return p_aux;
    };

    return Compound;

  })();

  /*
    Reaction object.
    There are two types of reactions objects:
    a) Normal reactions objects. They are created by the user.
    b) Virtual reactions objects. They are created by the system
       to represent a few normal reactions together. They are
       identified because they have a negative ID number. There's
       a counter and it's automatically assigned.
  
      All normal reactions are grouped and converted to virtual. Virtual
      reactions link virtual compounds. In this way, if two or more
      normal reactions takes the same compound, they are unified and only
      one virtual reaction is drawn.
  */


  window.Reaction = (function() {

    function Reaction(id, label, compound1, compound2, type) {
      this.id = id;
      this.label = label;
      this.compound1 = compound1;
      this.compound2 = compound2;
      this.type = type;
      this.virtual_reactions = [];
      this.paths = [];
    }

    Reaction.prototype.append_virtual_reaction = function(obj) {
      return this.virtual_reactions.push(obj);
    };

    Reaction.prototype.append_path = function(obj) {
      return this.paths.push(obj);
    };

    Reaction.prototype.get_paths = function() {
      return this.paths;
    };

    /*
        funtion get_coords()
        It returns a list of positions to define the path of a reaction.
        This 'path' depends on the relative position of both compounds
        and if some of the "important" positions are avaliable (if not,
        we try to assign alternative positions).
    */


    Reaction.get_coords = function(compound1, compound2, map) {
      var B, BOTTOM, DIRECT_BOTTOM, DIRECT_LEFT, DIRECT_RIGHT, DIRECT_TOP, L1_x, L1_y, L2_x, L2_y, LEFT, RIGHT, TOP, alt_pos, alt_pos1, alt_pos2, alt_x1, alt_x8, alt_y1, alt_y8, approach, cmp1, cmp2, ex, ey, p1_h, p1_w, p1_x, p1_y, p2_h, p2_w, p2_x, p2_y, pos, pos1, pos2, r, reversed, sx, sy, very_long, very_tall, x1, x8, y1, y8, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref27, _ref28, _ref29, _ref3, _ref30, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      B = 1;
      _ref = [B, B * -1, B * 2, B * -2], RIGHT = _ref[0], LEFT = _ref[1], DIRECT_RIGHT = _ref[2], DIRECT_LEFT = _ref[3];
      _ref1 = [3 * B, B * -3, B * 4, B * -4], TOP = _ref1[0], BOTTOM = _ref1[1], DIRECT_TOP = _ref1[2], DIRECT_BOTTOM = _ref1[3];
      _ref2 = [[compound1.position, compound1.size], [compound2.position, compound2.size]], cmp1 = _ref2[0], cmp2 = _ref2[1];
      (_ref3 = cmp1[0], p1_x = _ref3[0], p1_y = _ref3[1]), (_ref4 = cmp1[1], p1_w = _ref4[0], p1_h = _ref4[1]);
      (_ref5 = cmp2[0], p2_x = _ref5[0], p2_y = _ref5[1]), (_ref6 = cmp2[1], p2_w = _ref6[0], p2_h = _ref6[1]);
      reversed = false;
      if (p1_w < p2_w && p1_h < p2_h) {
        _ref7 = [compound2, compound1], compound1 = _ref7[0], compound2 = _ref7[1];
        _ref8 = [[compound1.position, compound1.size], [compound2.position, compound2.size]], cmp1 = _ref8[0], cmp2 = _ref8[1];
        (_ref9 = cmp1[0], p1_x = _ref9[0], p1_y = _ref9[1]), (_ref10 = cmp1[1], p1_w = _ref10[0], p1_h = _ref10[1]);
        (_ref11 = cmp2[0], p2_x = _ref11[0], p2_y = _ref11[1]), (_ref12 = cmp2[1], p2_w = _ref12[0], p2_h = _ref12[1]);
        reversed = true;
      }
      very_tall = p1_h > 10;
      very_long = p1_w > 10;
      L1_y = p1_y - p1_h / 2;
      L2_y = p1_y + p1_h / 2;
      L1_x = p1_x - p1_w / 2;
      L2_x = p1_x + p1_w / 2;
      if (p2_y < L1_y) {
        if (p2_x < L1_x) {
          approach = RIGHT;
          pos = [1, 2];
          alt_pos = [4, 3];
          if (very_tall) {
            approach = LEFT;
            pos = [1, 3];
          }
        } else if ((L1_x < p2_x && p2_x < L2_x)) {
          approach = DIRECT_TOP;
          pos = [1, 3];
        } else if (L2_x < p2_x) {
          approach = RIGHT;
          pos = [1, 4];
          alt_pos = [2, 3];
          if (very_tall) {
            approach = LEFT;
            pos = [1, 3];
          }
        }
      } else if ((L1_y < p2_y && p2_y < L2_y)) {
        if (p2_x < L1_x) {
          approach = DIRECT_RIGHT;
          pos = [4, 2];
        } else if ((L1_x < p2_x && p2_x < L2_x)) {

        } else if (L2_x < p2_x) {
          approach = DIRECT_RIGHT;
          pos = [2, 4];
        }
      } else if (L2_y < p2_y) {
        if (p2_x < L1_x) {
          approach = LEFT;
          pos = [4, 1];
          alt_pos = [3, 2];
          if (very_tall) {
            approach = RIGHT;
            pos = [3, 1];
          }
        } else if ((L1_x < p2_x && p2_x < L2_x)) {
          approach = DIRECT_BOTTOM;
          pos = [3, 1];
        } else if (L2_x < p2_x) {
          approach = LEFT;
          pos = [2, 1];
          alt_pos = [3, 4];
          if (very_tall) {
            pos = [3, 1];
          }
        }
      }
      pos1 = pos[0], pos2 = pos[1];
      _ref13 = compound1._get_base_coords(pos1, 0), sx = _ref13[0], sy = _ref13[1];
      _ref14 = compound1._get_base_coords(pos1, 3), x1 = _ref14[0], y1 = _ref14[1];
      _ref15 = compound2._get_base_coords(pos2, 3), x8 = _ref15[0], y8 = _ref15[1];
      _ref16 = compound2._get_base_coords(pos2, 0), ex = _ref16[0], ey = _ref16[1];
      /*
           For the alternative position we have two positiblities:
           - There's alternative positions defined and our first choice
           is busy, we check if the alternative position is free.
           - There's alternative positions defined and the intersection
           between the 2nd leg of both compounds is busy (so, the corner
           is busy), we try to change for the alternative position and
           check if the intersection is still busy.
      */

      if (alt_pos) {
        alt_pos1 = alt_pos[0], alt_pos2 = alt_pos[1];
        if ((map[x1] != null) && (map[x1][y1] != null)) {
          _ref17 = compound1._get_base_coords(alt_pos1, 3), alt_x1 = _ref17[0], alt_y1 = _ref17[1];
          if (!((map[alt_x1] != null) && (map[alt_x1][alt_y1] != null))) {
            _ref18 = compound1._get_base_coords(alt_pos1, 0), sx = _ref18[0], sy = _ref18[1];
            _ref19 = [alt_x1, alt_y1], x1 = _ref19[0], y1 = _ref19[1];
          }
        } else if (approach === RIGHT && ((map[x1] != null) && (map[x1][y8] != null))) {
          _ref20 = compound1._get_base_coords(alt_pos1, 3), alt_x1 = _ref20[0], alt_y1 = _ref20[1];
          if (!((map[alt_x1] != null) && (map[alt_x1][alt_y1] != null))) {
            _ref21 = compound1._get_base_coords(alt_pos1, 0), sx = _ref21[0], sy = _ref21[1];
            _ref22 = [alt_x1, alt_y1], x1 = _ref22[0], y1 = _ref22[1];
          }
        }
        if ((map[x8] != null) && (map[x8][y8] != null)) {
          _ref23 = compound2._get_base_coords(alt_pos2, 3), alt_x8 = _ref23[0], alt_y8 = _ref23[1];
          if (!((map[alt_x8] != null) && (map[alt_x8][alt_y8] != null))) {
            _ref24 = compound2._get_base_coords(alt_pos2, 0), ex = _ref24[0], ey = _ref24[1];
            _ref25 = [alt_x8, alt_y8], x8 = _ref25[0], y8 = _ref25[1];
          }
        } else if ((map[x8] != null) && (map[x8][y1] != null)) {
          _ref26 = compound2._get_base_coords(alt_pos2, 3), alt_x8 = _ref26[0], alt_y8 = _ref26[1];
          if (!((map[alt_x8] != null) && (map[alt_x8][alt_y8] != null))) {
            _ref27 = compound2._get_base_coords(alt_pos2, 0), ex = _ref27[0], ey = _ref27[1];
            _ref28 = [alt_x8, alt_y8], x8 = _ref28[0], y8 = _ref28[1];
          }
        }
      }
      if (approach === RIGHT) {
        r = [[sx, sy], [x1, y1], [x1, y8], [x8, y8], [ex, ey]];
        if (x8 < ex) {
          _ref29 = [ex, ey], x8 = _ref29[0], y8 = _ref29[1];
        }
        r = [[sx, sy], [x1, y1], [x1, y8], [x8, y8], [ex, ey]];
      } else if (approach === LEFT) {
        if (x8 < ex) {
          _ref30 = [ex, ey], x8 = _ref30[0], y8 = _ref30[1];
        }
        r = [[sx, sy], [x1, y1], [x8, y1], [x8, y8], [ex, ey]];
      } else if (approach === DIRECT_RIGHT) {
        r = [[sx, y8], [x1, y8], [x8, y8], [ex, y8]];
      } else if (approach === DIRECT_LEFT) {
        r = [[sx, y1], [x1, y1], [x8, y1], [ex, y1]];
      } else if (approach === DIRECT_BOTTOM) {
        r = [[x8, sy], [x8, y1], [x8, y8], [x8, ey]];
      } else if (approach === DIRECT_TOP) {
        r = [[x8, sy], [x8, y1], [x8, y8], [x8, ey]];
      }
      return r;
    };

    return Reaction;

  })();

  /*
    Class pathway:
  
    It defines each pathway with its reactions, compounds, etc.
  
    It also have the compound map... where it's controlled which
    positions are busy or free.
  */


  Pathway = (function() {

    function Pathway(id, title, description) {
      var text;
      this.id = id;
      this.title = title;
      this.description = description;
      console.log("[INFO] Initialised pathway " + this.id);
      this.compounds = {};
      this.reactions = {};
      this.compound_groups = {};
      this.map = {};
      this.virtual_compounds = {};
      this.map_compounds = {};
      this.virtual_compound_id = -1;
      this.virtual_reactions = {};
      this.layer = new paper.Layer();
      text = new paper.PointText(new paper.Point(80, 25), new paper.Size(200, 100));
      text.justification = 'center';
      text.fillColor = 'black';
      text.fontSize = '14px';
      text.content = this.title;
    }

    /*
       get_compound_instance: (compound_id) returns compound_id
    
       Given a compound_id, we get another compound id. If it is a positive
       integer is a 'normal compound'; if it is a negative integer is a
       virtual compound that is created from two or more compounds.
    */


    Pathway.prototype.get_compound_instance = function(compound_id) {
      if (this.map_compounds[compound_id] != null) {
        return this.map_compounds[compound_id];
      }
      return compound_id;
    };

    Pathway.prototype.set_map = function(compound_id) {
      var compound, h, position, w, x, x1, x2, y, y1, y2, _base, _i, _ref, _ref1, _ref2, _ref3, _results;
      compound = this.compounds[compound_id];
      position = compound["position"];
      _ref = [compound["size"][0], compound["size"][1]], w = _ref[0], h = _ref[1];
      _ref1 = [parseInt(position[0] - (w / 2)), parseInt(position[1] - (h / 2)), parseInt(position[0] + (w / 2)), parseInt(position[1] + (h / 2))], x1 = _ref1[0], y1 = _ref1[1], x2 = _ref1[2], y2 = _ref1[3];
      _results = [];
      for (x = _i = x1, _ref2 = x2 - 1; x1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; x = x1 <= _ref2 ? ++_i : --_i) {
        if ((_ref3 = (_base = this.map)[x]) == null) {
          _base[x] = {};
        }
        _results.push((function() {
          var _j, _ref4, _results1;
          _results1 = [];
          for (y = _j = y1, _ref4 = y2 - 1; y1 <= _ref4 ? _j <= _ref4 : _j >= _ref4; y = y1 <= _ref4 ? ++_j : --_j) {
            _results1.push(this.map[x][y] = compound_id);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    /*
       get_4_neighbors_compound
       This function returns the neighbour points for the compound group
       generation. So, given a compound_id it returns the N, W, E, S from
       that compound (or virtual compound).
    
             N
         ---------
       W |  cpd  | E
         ---------
             S
    */


    Pathway.prototype.get_compound_neighbors = function(compound_id) {
      var c, c_id, compound_list, coords, hd, sx, sy, wd, x, y, _i, _len, _ref, _ref1, _ref2;
      c_id = this.get_compound_instance(compound_id);
      c = this.compounds[c_id];
      _ref = [parseInt(c.size[0] / 2), parseInt(c.size[1] / 2)], wd = _ref[0], hd = _ref[1];
      _ref1 = [parseInt(c.position[0]), parseInt(c.position[1])], x = _ref1[0], y = _ref1[1];
      compound_list = [];
      coords = [[x - wd - 1, y], [x + wd, y], [x, y - hd - 1], [x, y - hd - 2], [x, y + hd], [x - wd - 1, y - hd - 1], [x + wd + 1, y - hd - 1]];
      for (_i = 0, _len = coords.length; _i < _len; _i++) {
        _ref2 = coords[_i], sx = _ref2[0], sy = _ref2[1];
        if (this.is_busy_coords(sx, sy)) {
          compound_list.push(this.get_compound_coords(sx, sy));
        }
      }
      return compound_list;
    };

    Pathway.prototype.is_busy = function(point) {
      var x, y, _ref;
      _ref = [point[0], point[1]], x = _ref[0], y = _ref[1];
      return (this.map[x] != null) && (this.map[x][y] != null);
    };

    Pathway.prototype.is_busy_coords = function(x, y) {
      return (this.map[x] != null) && (this.map[x][y] != null);
    };

    Pathway.prototype.get_compound = function(point) {
      var x, y, _ref;
      _ref = [point[0], point[1]], x = _ref[0], y = _ref[1];
      if ((this.map[x] != null) && (this.map[x][y] != null)) {
        return this.map[x][y];
      }
    };

    Pathway.prototype.get_compound_coords = function(x, y) {
      if ((this.map[x] != null) && (this.map[x][y] != null)) {
        return this.map[x][y];
      }
    };

    /*
        function build_virtual_compounds()
        In order to build the virtual compounds in two steps:
        We take any initial compound and we browse through
        its connections. Everytime that we cannot access to any
        new neighbour connected with our initial compound, we
        created a new group and we take a new compound that has
        not been analysed previously.
    
        Afterwards, for each group we create a virtual compound
        and we link all the compounds from the group to this
        new virtual compound.
    */


    Pathway.prototype.build_virtual_compounds = function() {
      var c_group, c_id, cmp, cmp_id, compound_id, inf, max, max_x, max_y, min, min_x, min_y, new_compound, opened, p, pending, position, s, size, visited, x, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results;
      pending = Object.keys(this.compounds);
      c_group = {};
      visited = [];
      while (pending.length > 0) {
        compound_id = pending.pop();
        opened = [compound_id];
        visited.push(compound_id);
        c_group[compound_id] = [compound_id];
        while (opened.length > 0) {
          c_id = opened.pop();
          _ref = this.get_compound_neighbors(c_id);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            new_compound = _ref[_i];
            if (__indexOf.call(visited, new_compound) < 0) {
              visited.push(new_compound);
              opened.push(new_compound);
              c_group[compound_id].push(new_compound);
            }
          }
        }
        pending = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = pending.length; _j < _len1; _j++) {
            x = pending[_j];
            if (visited.indexOf(x) === -1) {
              _results.push(x);
            }
          }
          return _results;
        })();
      }
      _ref1 = [Math.min, Math.max, 32768], min = _ref1[0], max = _ref1[1], inf = _ref1[2];
      _results = [];
      for (compound_id in c_group) {
        if (c_group[compound_id].length > 1) {
          this.virtual_compound_id -= 1;
          this.virtual_compounds[this.virtual_compound_id] = c_group[compound_id];
          _ref2 = [inf, inf, -inf, -inf], min_x = _ref2[0], min_y = _ref2[1], max_x = _ref2[2], max_y = _ref2[3];
          _ref3 = c_group[compound_id];
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            cmp_id = _ref3[_j];
            cmp = this.compounds[cmp_id];
            this.compounds[cmp_id].virtual_compound_id = this.virtual_compound_id;
            _ref4 = [cmp.position, cmp.size], p = _ref4[0], s = _ref4[1];
            _ref5 = [parseInt(min(min_x, p[0] - s[0] / 2)), parseInt(min(min_y, p[1] - s[1] / 2))], min_x = _ref5[0], min_y = _ref5[1];
            _ref6 = [parseInt(max(max_x, p[0] + s[0] / 2)), parseInt(max(max_y, p[1] + s[1] / 2))], max_x = _ref6[0], max_y = _ref6[1];
          }
          size = [get_m2c_point(max_x - min_x), get_m2c_point(max_y - min_y)];
          position = [get_m2c_point(max_x) - size[0] / 2, get_m2c_point(max_y) - size[1] / 2];
          _results.push(this._add_compound(compound_id = this.virtual_compound_id, "Virtual cmp " + this.virtual_compound_id, "Virtual cmp", position, size, "square", ["red", "blue"]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Pathway.prototype._add_compound = function(compound_id, label, description, position, size, shape, color, virtual) {
      var id, m_size_x, m_size_y, path;
      if (virtual == null) {
        virtual = false;
      }
      try {
        this.compounds[compound_id] = new Compound(id = compound_id, label = label, description = description, position = [get_c2m_point(position[0]), get_c2m_point(position[1])], size = [get_c2m_point(size[0]), get_c2m_point(size[1])], shape = shape, color = color, path = this.path, virtual = virtual);
        m_size_x = get_m2c_point(position[0] + size[0]);
        if (!(this.max_size_x != null) || m_size_x > this.max_size_x) {
          this.max_size_x = m_size_x;
        }
        m_size_y = get_m2c_point(position[1] + size[1]);
        if (!(this.max_size_y != null) || m_size_y > this.max_size_y) {
          return this.max_size_y = m_size_y;
        }
      } catch (error) {
        console.log("[ERROR] Trying to add compoound id:", compound_id);
        return console.log(error);
      }
    };

    /*
      function add_compound_list(compound_list)
    
      Given a list of compounds i's added to a pathway. We also update
      the map of avaliable postiions and, afterwards, it's also built
      the virtual compounds.
    */


    Pathway.prototype.add_compound_list = function(compound_list) {
      var c, _i, _len;
      for (_i = 0, _len = compound_list.length; _i < _len; _i++) {
        c = compound_list[_i];
        this._add_compound(c.id, c.label, c.description, c.position, c.size, c.shape, c.color);
        this.set_map(c.id);
      }
      return this.build_virtual_compounds();
    };

    /*
        function set_pathway_offsets.
        Given an offset, the layer is translated (x, y) units.
    
        This function is used at the end to move each pathway
        depending on the size of the screen and the numbe rof pathways.
    */


    Pathway.prototype.set_pathway_offsets = function(x, y) {
      this.layer.translate(x, y);
      return this.layer.activate();
    };

    /*
        internal function to add a reaction.
    
        One single reaction can have more than one reaction associated.
        A reaction can be between a "real compound" or a "virtual compound".
    */


    Pathway.prototype._add_reaction = function(id, label, compound1_id, compound2_id, type) {
      var compound1, compound2, cpd1_v, cpd2_v, r, _i, _len, _ref, _ref1, _results;
      compound1 = this.compounds[compound1_id];
      compound2 = this.compounds[compound2_id];
      if (this.reactions[id] != null) {
        this.reactions[id].push(new Reaction(id, label, compound1, compound2, type));
      } else {
        this.reactions[id] = [new Reaction(id, label, compound1, compound2, type)];
      }
      if (compound1.virtual_compound_id != null) {
        cpd1_v = compound1.virtual_compound_id;
      } else {
        cpd1_v = compound1.id;
      }
      if (compound2.virtual_compound_id != null) {
        cpd2_v = compound2.virtual_compound_id;
      } else {
        cpd2_v = compound2.id;
      }
      if (cpd1_v > cpd2_v) {
        _ref = [cpd2_v, cpd1_v], cpd1_v = _ref[0], cpd2_v = _ref[1];
      }
      if (this.virtual_reactions[[cpd1_v, cpd2_v]] != null) {
        if (__indexOf.call(this.virtual_reactions[[cpd1_v, cpd2_v]]['type'], type) < 0) {
          this.virtual_reactions[[cpd1_v, cpd2_v]]['type'].push(type);
          this.virtual_reactions[[cpd1_v, cpd2_v]]['reaction'].push(id);
        }
      } else {
        this.virtual_reactions[[cpd1_v, cpd2_v]] = {
          'type': [type],
          'reaction': [id]
        };
      }
      _ref1 = this.reactions[id];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        r = _ref1[_i];
        _results.push(r.append_virtual_reaction([cpd1_v, cpd2_v]));
      }
      return _results;
    };

    Pathway.prototype.add_reaction_list = function(reaction_list) {
      var r, _i, _len;
      for (_i = 0, _len = reaction_list.length; _i < _len; _i++) {
        r = reaction_list[_i];
        this._add_reaction(r.id, r.label, r.compound1_id, r.compound2_id, r.type);
      }
      paper.view.draw();
      return this.draw_reactions();
    };

    Pathway.prototype.draw_reactions = function() {
      var cpd1, cpd2, p, p1, p2, paper_path, r, r_id, reaction_path, s, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      for (r in this.virtual_reactions) {
        _ref = [r.split(",")[0], r.split(",")[1]], cpd1 = _ref[0], cpd2 = _ref[1];
        try {
          _ref1 = [this.compounds[cpd1].position, this.compounds[cpd2].position], p1 = _ref1[0], p2 = _ref1[1];
          reaction_path = Reaction.get_coords(this.compounds[cpd1], this.compounds[cpd2], this.map);
          paper_path = new paper.Path();
          paper_path.strokeColor = 'black';
          _ref2 = this.virtual_reactions[r]["reaction"];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            r_id = _ref2[_i];
            _ref3 = this.reactions[r_id];
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              s = _ref3[_j];
              s.append_path(paper_path);
            }
          }
          for (_k = 0, _len2 = reaction_path.length; _k < _len2; _k++) {
            p = reaction_path[_k];
            paper_path.add(new paper.Point(p[0] * 4, p[1] * 4));
          }
        } catch (error) {
          console.log("--- oops", error);
          console.log("cpd1", cpd1, "cpd2", cpd2, "::");
          console.log("r", r);
        }
      }
      return paper.view.draw();
    };

    return Pathway;

  })();

  SELECTED_GROUP = null;

  AlignResult = (function() {

    function AlignResult(id, r_align, reaction1, reaction2) {
      var color1, color2, r3, r4, style_aligned, style_highlighted, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1,
        _this = this;
      this.id = id;
      color1 = r_align["color1"];
      color2 = r_align["color2"];
      this.g1 = new paper.Group();
      this.g2 = new paper.Group();
      try {
        for (_i = 0, _len = reaction1.length; _i < _len; _i++) {
          r3 = reaction1[_i];
          _ref = r3["paths"];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            r4 = _ref[_j];
            this.g1.addChild(r4);
          }
        }
        for (_k = 0, _len2 = reaction2.length; _k < _len2; _k++) {
          r3 = reaction2[_k];
          _ref1 = r3["paths"];
          for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
            r4 = _ref1[_l];
            this.g2.addChild(r4);
          }
        }
      } catch (e) {
        console.log("error adding groups");
        console.log(e);
      }
      style_aligned = {
        opacity: 1,
        strokeColor: color1,
        strokeWidth: 3,
        closed: false
      };
      style_highlighted = {
        opacity: 1,
        strokeColor: color2,
        strokeWidth: 3,
        closed: false
      };
      this.g1.style = style_aligned;
      this.g2.style = style_aligned;
      this.g1.onMouseEnter = function(event) {
        if (SELECTED_GROUP != null) {
          SELECTED_GROUP[0].style = style_aligned;
          SELECTED_GROUP[1].style = style_aligned;
        }
        SELECTED_GROUP = [_this.g1, _this.g2];
        _this.g1.bringToFront();
        _this.g2.bringToFront();
        _this.g1.style = style_highlighted;
        return _this.g2.style = style_highlighted;
      };
      this.g2.onMouseEnter = function(event) {
        if (SELECTED_GROUP != null) {
          SELECTED_GROUP[0].style = style_aligned;
          SELECTED_GROUP[1].style = style_aligned;
        }
        SELECTED_GROUP = [_this.g1, _this.g2];
        _this.g1.bringToFront();
        _this.g2.bringToFront();
        _this.g1.style = style_highlighted;
        return _this.g2.style = style_highlighted;
      };
    }

    return AlignResult;

  })();

  iEnhancedCanvas = (function() {

    function iEnhancedCanvas(canvas_id) {
      this.canvas_id = canvas_id;
      this.compounds = {};
      this.pathway_list = [];
      this.canvas = document.getElementById(this.canvas_id);
      paper.setup(this.canvas);
      this.paper_view = paper.view;
    }

    iEnhancedCanvas.prototype.setup = function() {
      var h, total_size_x, total_size_y, w, width, z, z1, z2, _ref, _ref1;
      width = paper.view.size.width / this.pathway_list.length;
      _ref = [$(document).width(), $(document).height()], w = _ref[0], h = _ref[1];
      console.log(paper.view.size.width);
      _ref1 = [0, 0], total_size_x = _ref1[0], total_size_y = _ref1[1];
      this.pathway_list.forEach(function(pathway, e) {
        console.log(pathway.max_size_x, pathway.max_size_y);
        total_size_x += pathway.max_size_x;
        return total_size_y = Math.max(total_size_y, pathway.max_size_y);
      });
      z1 = $(document).width() / total_size_x;
      z2 = $(document).height() / total_size_y;
      z = Math.min(z1, z2);
      console.log("total Size", total_size_x, total_size_y);
      console.log("Size", w, h);
      console.log("Z", z, z1, z2);
      console.log(total_size_x, $(document).width());
      console.log(total_size_y, $(document).height());
      if (z < 1) {
        paper.view.zoom = z;
        paper.view.center = [total_size_x / 2, total_size_y / 2];
      }
      width = paper.view.size.width / this.pathway_list.length;
      return this.pathway_list.forEach(function(pathway, e) {
        pathway.set_pathway_offsets(e * width, 0);
        return paper.view.draw();
      });
    };

    iEnhancedCanvas.prototype.list_pathways = function() {
      return console.log('Pathways' + pathway_list);
    };

    iEnhancedCanvas.prototype.new_pathway = function(id, title, description, width, height, canvas_id) {
      var pathway;
      console.log("[INFO] Adding pathway " + id + " (" + width + ", " + height + ")");
      console.log("       Title: " + title);
      console.log("       Description: " + description);
      pathway = new Pathway(id, title, description);
      this.pathway_list.push(pathway);
      return pathway;
    };

    iEnhancedCanvas.prototype.add_result = function(result_list) {
      var align_id, r_align, reaction1, reaction2, result_group, _i, _len;
      result_group = {};
      for (_i = 0, _len = result_list.length; _i < _len; _i++) {
        r_align = result_list[_i];
        align_id = r_align["id"];
        reaction1 = this.pathway_list[r_align['pathway1_id']]["reactions"][r_align["reaction1_id"]];
        reaction2 = this.pathway_list[r_align['pathway2_id']]["reactions"][r_align["reaction2_id"]];
        result_group[align_id] = new AlignResult(align_id, r_align, reaction1, reaction2);
      }
      return paper.view.draw();
    };

    return iEnhancedCanvas;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (!root.iEnhancedCanvas) {
    root.iEnhancedCanvas = iEnhancedCanvas;
  }

}).call(this);
